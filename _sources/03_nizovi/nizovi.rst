Рад са низовима података
========================

Када прикупљамо податке, то су увек неки низови. Некада су елементи тих
низова једноставни бројчани подаци, на пример максимална дневна
температура. Ако те податке прикупљамо сваки дан у јуну, имаћемо на
крају низ од тридесет бројева. Са друге стране, подаци могу да буду
веома сложени. Замислите прикупљање података о паду Римског царства. Ту
елемент низа може да буде садржај целе једне књиге. Свеједно, подаци се
прикупљају, бележе и чувају у различитим варијантама низова.

У Пајтону низове података представљамо различитим колекцијама. Ипак, то
најчешће радимо помоћу колекције типа **листа**. Колекција типа
**торке** (енгл. *tuples*) су сличне листама. Оно што им је заједничко
јесте да могу да се индексирају. То значи да елементима можемо да
приступимо по редном броју, тј. да знамо који је елемент други, а који
пети. Оно што је различито код листа и торки је да прве можемо да
мењамо, односно да додајемо, бришемо и мењамо елементе. Још једна
разлика између листа и торки је што прве набрајамо унутар угластих, а
друге унутар обучних заграда. Торке су непроменљиве. У наставку ове
свеске ћемо се бавити само листама, али вас то не спречава да исто ово
пробате и са торкама.

Рад са листама
--------------

Листе су најопштије колекције података у којима може да буде података
било ког типа. Због тога нема много конкретних и ефикасних функција за
рад са листама. Тек када се подаци сложе у униформне низове или табеле,
отвара се могућност за једноставну манипулацију података и статистичку
анализу. Колико ефикасан може да буде тај рад видећете када будемо
почели да користимо Пајтонове библиотеке. Ми ћемо се, за сад, бавити
само оним скромним арсеналом операција и функција за рад са листама у
општем случају.

Управљање листом – индекси и слајсови
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Листе допуштају измене, допуне и брисање њених делова или појединачних
елемената листе. Да бисмо могли да управљамо листом, потребно је да
знамо како приступамо њеним деловима. За то користимо појединачне
индексе и “слајсове”. Видећете на примерима како се они користе.

Елементима листе можемо да приступимо по индексу тако што индекс (редни
број елемента који креће од нуле) ставимо у угласте заграде после имена
листе. Тако први елемент листе ``L`` добијамо са ``L[0]``, други са
``L[1]`` итд. Исти елемент можемо да означимо са два индекса: једним
који иде од почетка ка крају листе или по индексу који иде од краја ка
почетку. У првом случају, индекс узима вредности од 0 до *n*-1, где је
*n* дужина листе, док у другом има вредности од -1 (последњи елемент
низа) до -*n* (први елемент).

.. activecode:: lista1
    :nocodelens:
    :passivecode: True

    L=["I","II","III","IV","V","VI","VII","VIII","IX","X"]

.. activecode:: lista22
    :nocodelens:
    :include: lista1

    print(L[8]==L[-2])          # proveravamo da li su vrednosti elemenata sa indeksima 8 i -2 jednake
    

Слајс је део листе који дефинишемо задајући индекс почетка и индекс који
је за један већи од индекса краја. Ова два броја стављамо унутар
угластих заграда, а раздвајамо их помоћу две тачке, ``:``. На пример, да
елементе са индексима 2 и 3 издвајамо помоћу слајса ``[2:4]``.

.. activecode:: lista3
    :nocodelens:
    :include: lista1

    print(L[2:4])

Уколико изоставимо неки број у слајсу, Пајтон подразумева да је то 0,
ако је изостављен са леве стране, односно *n* ако је изостављен са
десне. Тако све елементе од оног са индексом 2 па до краја листе можемо
да издвојимо са ``L[2:]``, док првих пет можемо да издвојимо са
``L[:5]``. Ако изоставимо и леву и десну границу слајса, добићемо целу
листу, од почетка до краја. Пробајте ове комбинације.

.. activecode:: lista4
    :nocodelens:
    :include: lista1

    print(L[:5])


Слајсови могу да имају и трећи аргумент који задаје корак. На пример,
ако хоћемо све елементе од индекса 3 до 7 тако што узимамо сваки други,
то записујемо као слајс ``[3:8:2]``.

.. activecode:: lista5
    :nocodelens:
    :include: lista1

    print(L[3:8:2])


Корак у слајсу може да буде и негативан. Онда вредности из листе узима
уназад. На пример, када хоћемо последњих пет у обрнутом редоследу, треба
да напишемо ``L[-1:-5:-1]``.

.. activecode:: lista6
    :nocodelens:
    :include: lista1

    print(L[-1:-5:-1])

Можете ли да претпоставите шта ће нам дати ``L[::-1]``? Овде смо
пропустили да назначимо одакле докле узимамо елементе листе за слајс,
само смо рекли да иде уназад. Јасно, слајс ће узети целу листу и обрнути
редослед елемената.

.. activecode:: lista7
    :nocodelens:
    :include: lista1

    print(L[::-1])


Операције са листама
~~~~~~~~~~~~~~~~~~~~

Код листа постоје операције сабирања и множења. Треба имати у виду да се
ове операције односе на листе, а не на њихове вредности. Због тога
операције можда неће радити оно што од њих очекујете. Погледајте
примере.

.. activecode:: operacije1
    :nocodelens:

    a=[1,2,3]
    b=[3,4]
    
    print(a+b)
    print(a*3)

Операција сабирања спаја два листе. Множење листе и броја *m* прави нову
листу у којој је прва листа поновљена *m* пута.

Основне функције за рад са листама
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Све функције, без обзира да ли су дефинисане у Пајтону или их ми пишемо,
по правилу имају улазне и излазне променљиве. Променљиве које уносимо
функција обрађује и враћа резултат, тј. вредност излазне променљиве.
Функција се обично позива преко имена функције и аргумента у загради.
Аргументе можемо да замислимо као паркинг места на која треба да ставимо
називе неких променљивих. На пример, код функције која враћа дужину
листе (``len()``) постоји један аргумент где ми ставимо име улазне
променљиве, односно листе чију дужину желимо да сазнамо. Ако ставимо
``len(L)`` функција ће нам вратити дужину листе L.

Пајтон има две врсте функција: оне где променљиве стављамо у заграде као
аргументе, нпр. ``sum(lista)``, и оне где се функције наводе у наставку
после имена променљиве и тачке, нпр. ``lista.sort()``. Ове друге се
иначе називају методама. Разлика између ове две врсте функција за нас
није посебно важна. Ми ћемо их, због једноставности, и једне и друге
звати функцијама, само ћемо када помињемо ове друге стављати тачку
испред имена функције.

Функције ``len()``, ``min()``, ``max()`` и ``sum()`` враћају дужину
листе, минималну и максималну вредност, као и збир свих вредности у
листи.

.. activecode:: vrednosti
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    
    print('Dužina liste je', len(lista))
    print('Najmanja vrednost u listi je', min(lista))
    print('Najveća vrednost u listi je', max(lista))
    print('Zbir svih vrednosti u listi je', sum(lista))


Оних других функција за рад са листа чија се имена наводе после имена
променљиве има нешто више. Не морате све да их знате, али је корисно да
знате да постоје. Примери ови метода ће бити довољни да разумете шта
раде.

``.append()`` додаје још један елемент у листу. У следећем примеру листи
додаје елемент са бројем 5.

.. activecode:: dodavanje
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    lista.append(5)
    print(lista)


``.remove()`` уклања први елемент који има наведену вредност.

.. activecode:: oduzimanje
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    lista.remove(5)
    print(lista)


``.index()`` даје индекс првог елемента у листи који има наведену
вредност.

.. activecode:: index
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    a = lista.index(2)
    print(a)


``.count()`` прребројава колико се пута наведена вредност појављује у
листи.

.. activecode:: count
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    a = lista.count(4)
    print(a)



``.insert()`` убацује у листу на место са одређеним индексом вредност
која је наведена као други аргумент. Обратите пажњу да ова метода има
два аргумента: први је индекс на који убацујемо нови елемент, а други
вредност тог елемента.

.. activecode:: inserts
    :nocodelens:

    lista=[]
    lista.insert(3,5)
    print(lista)


``.pop()`` “вади” елемент са одређеним индексом из листе. Метод враћа
вредност тог елемента при чему се елемент брише из листе.

.. activecode:: pop
    :nocodelens:
    
    lista=[3,2,2,5,1,4,4]
    v=lista.pop(6)
    print('Izvadili smo iz liste prvi element sa vrednošću',v)
    print('Ostala je skraćena lista',lista)
    
``.reverse()`` обрће редослед елемената у листи. То је исто оно што смо
раније добили помоћу *слајса* ``[::-1]``.

.. activecode:: reverse
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    lista.reverse()
    print(lista)
    

``.sort()`` сортира вредности у листи по величини почевши од најмање.

.. activecode:: sort
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    lista.sort()
    print(lista)


.. suggestionnote::
    
    Важно је да приметите како методе мењају листе на које се примењују.
    Примера ради, ``lista.sort()`` неће само вратити сортирану листу него ће
    ту листу трајно променити. Ово не можемо лако да вратимо назад јер не
    постоји “*.unsort*”. Ако нисмо запамтили претходно стање, не знамо у шта
    да га вратимо. Зато је понекад добро чувати копије оригиналних листа.


Метода ``.copy()`` баш томе служи, копира једну листу у другу. Ако прву
променимо, друга ће памтити старе вредности.

.. activecode:: copy
    :nocodelens:

    lista=[3,2,2,5,1,4,4]
    lista_original=lista.copy()
    lista.sort()
    print('Originalna lista',lista_original)
    print('Sortirana lista',lista)

    

На крају приче о функцијама, треба да знате да оне могу имати и више
аргумената. То спада у неки напреднији курс. Ако сте заинтересовани,
пробајте сами да откријете који су то аргументи и шта тако можете да
добијете.

Корисничке функције за рад са листама
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

У овој свесци смо видели практично све функције за рад са листама које
Пајтон има у својој стандардној библиотеци. За специфичније и
конкретније намене можете сами да напишете као корисничку функцију. Све
што можете да напишете у самом програму, можете и у функцији коју
касније било кад можете да позовете.

Улазне и излазне променљиве код функција могу да буду и листе. Пример
функције која враћа листу је обртање редоследа елемената у листи. Ова
функција такође постоји у стандардној библиотаци и зове се
``.reverse()``. Како бисте ви написали ову функцију? Вероватно је
најједноставније помоћу *слајса* ``[::-1]``. Пробајте на нађете још неки
начин.

.. activecode:: obrni
    :nocodelens:

    def obrni(L):
        R=L[::-1]
        return R
    lista=[3,2,2,5,1,4,4]
    print(obrni(lista))


Претраживање листе помоћу *for* петље
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Кад претражујемо листу ми за сваку вредност у листи проверавамо да ли
испуњава одређени услов. Другим речима, проверавамо испуњеност одређеног
логичког исказа за сваки елемент листе. Пајтонове библиотеке имају много
могућности за претраживање низова различитих типова. Те могућности ћемо
оставити за касније. Сада ћемо да видимо како да листу претражимо без
увожења додатних библиотека. Главна полуга тог механизма је коришћење
*for* петље.

Кроз петљу пролазимо елемент по елемент и проверавамо да ли је услов
испуњен. Свака *for* петља има бројач који је тренутно актуелни елемент
и тај бројач се мења у сваком пролазу. У наставку следи неколико примера
претраживања помоћу *for* петље. Обратите пажњу да некада бројач у петљи
изима вредности из листе (прва два примера), а некад из колекције
*range* која садржи индексе свих елемената листе (друга два примера). Да
би *range* заиста обухватио све индексе листе потребно је да му
проследимо аргумент ``len(lista)`` који говори колико је листа дугачка.

.. questionnote:: 
    
    Који су све бројеви у листи мањи од 20?

.. activecode:: for_pretrazivanje
    :nocodelens:

    lista=[11,22,33,28,25,36,17,28,39,10,21,32]   # definišemo vrednosti elemenata liste
    for n in lista:                               # za svaku vrednost n iz liste
        if n<20:                                  # proveravamo da li je n manje od 20
            print(n)                              # ako jeste, ispisujemo tu vrednost
    

.. questionnote:: 
    
    Који су све бројеви у листи дељиви са 3? 

.. activecode:: deljivi_3
    :nocodelens:

    lista=[11,22,33,28,25,36,17,28,39,10,21,32]
    for n in lista:
        if n%3==0:          # i%3==0 znači da je ostatak pri deljenju i sa 3 jednak nuli
            print(n)


.. suggestionnote:: Напомена

   Напомена: Ако сте до сада пропустили да научите чему служе оператори ``%``
   и ``//``, да исправимо сада тај пропуст. Помоћу њих израчунавамо
   целобројни резултат дељења и остатак при том дељењу. На пример, кад
   17 делимо са 3, добијамо целобројни резултат 5 и остатак 2.
   Целобројни количник добијамо са ``17//3``, а остатак при том дељењу
   са ``17%3``. Ако су бројеви *m* и *n* дељиви, онда нема остатка при
   дељењу. Другим речима, остатак је једнак нули: ``m%n==0``.

.. questionnote::
    
    Који су индекси елемената са вредношћу 28?

.. activecode:: indeks
    :nocodelens:

    lista=[11,22,33,14,25,36,17,28,39,10,21,32]
    for i in range(len(lista)):   # za sve moguće indekse od 0 do n-1
        if lista[i]==28:          # proveravamo da li je vrednost lista[i] jednaka 28
            print(i)              # ako jeste, ispisujemo je


.. infonote::

   Пајтон има уграђену функцију ``.index()`` која враћа индекс првог елемента са траженом вредношћу. Она би за израз ``lista.index(28)`` вратила само индекс ``3``.

.. questionnote::

    Који су индекси непарних бројева у листи?

.. activecode:: neparni
    :nocodelens:

    lista=[11,22,33,14,25,36,17,28,39,10,21,32]
    for i in range(len(lista)):
        if lista[i]%2==1:       # ostatak pri deljenju sa 2 je 1, znači da je broj neparan
            print(i)
    

Издвајање делова листе
~~~~~~~~~~~~~~~~~~~~~~

Да бисмо издвојили елементе листе који нас интересују, потребно је да
знамо на којим се позицијама налазе. Ако знамо њихове индексе, онда само
треба проћи кроз листу, узети елементe са тим индексима и ставити их у
нову листу. Уколико индексе не знамо већ имамо само критеријум који
вредност елемента листе треба да испуни, онда треба проћи кроз листу,
видети који елементи задовољавају тражени критеријум, узети њихове
вредности и ставити их у нову листу.

Издвајање делова листе помоћу *for* петље
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Најједноставнији начин за издвајање одређених елемената или делова листе
је коришћењем *for* петље. Истина, ту треба написати највише линија
кôда, али нема ограничења колико сложени могу да буду критеријуми.
Логика издвајања тражених елемената је једноставна: осим оригиналне
листе, имамо другу у којој су индекси елемената које хоћемо да издвојимо
и трећу у коју стављамо издвојене елементе. Ова трећа листа је на
почетку празна, али је онда при наредним итерацијама (тј. проласцима
кроз петљу) допуњујемо траженим елементима помоћу функције
``.append()``. Погледајте пример како из листе издвајамо само елементе
са индексима 2, 3 и 6.

.. activecode:: for_elementi
    :nocodelens:

    lista=['a','b','c','d','e','f','g','h']
    indeksi=[2,3,6]
    izdvojeni=[]
    for i in indeksi:                # za svaki element i iz liste indeksi
        izdvojeni.append(lista[i])   # dopuni listu izdvojeni vrednošću lista[i]
    print(izdvojeni)


Уколико не знамо индексе већ само услове за елементе које треба
издвојити, морамо прво да проверимо да ли су испуњени. Ако елемент
испуњава услов, онда тај елемент издвајамо. Примера ради, из претходно
одређене листе ``lista`` можемо, на пример, да издвојимо само оне
елементе чије су вредности самогласници.

.. activecode:: for_eleemnti2

    lista=['a','b','c','d','e','f','g','h']
    samoglasnici=['a','e','i','o','u']
    izdvojeni=[]
    for x in lista:
        if x in samoglasnici:
            izdvojeni.append(x)
    print(izdvojeni)


Издвајање делова листе помоћу слајсова
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Пајтон допушта да индексе елемената које желимо да издвојимо представимо
као слајс. Овај начин је врло једноставан, али ограниченог домета
примене. Слајсови су само једноставни низови индекса. Ту нема места за
било какве услове. Слајсови не могу да буду било који низови индекса већ
само елементи чији се индекси периодично понављају. На пример, слајс за
прва три елемента је ``[:3]``, слајс за елементе са индексима од 3 до 6
је ``[3:7]`` док слајс за сваки други елемент почевши од индекса 1 има
облик ``[1::2]``.

Ево једног примера где би издвајање помоћу слајсова могло да помогне. У
листи имамо наизменично имена и презимена, а желимо да издвојимо само
презимена. Како то да учинимо?

.. activecode:: slajsovi
    :nocodelens:

    teniseri_SRB=['Miomir','Kecmanović','Laslo','Đere','Dušan','Lajović','Novak','Đoković','Filip','Krajinović']
    print(teniseri_SRB[1::2])      # u uglastim zagradama je slajs za niz indeksa od 1 do kraja     liste sa korakom 2  




Да хоћемо да издвојимо само имена, требало би да узмемо сваки други
елемент почевши од индекса 0: ``teniseri_SRB[0::2]``.

Издвајање делова листе помоћу *list comprehension* конструкције
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Издвајање елемената из листе тако што за то пишемо програм није нарочито
елегантно решење. Коришћење *list comprehension* конструкције је много
елегантније јер омогућава издвајање елемената листе у само једној линији
кôда. У средњој школи ћете учити детаљније како се користи *list
comprehension* конструкција. Зато је нећемо овде посебно објашњавати. То
вас, међутим, не спречава да пробате ову конструкцију, сами закључите
како ради и почнете да је примењујете. За посебно нестрпљиве, предлажемо
да погледају исти овај курс за други разред средње школе. Тамо је све
објашњено.

.. activecode:: comprehension
    :nocodelens: 

    lista=['a','b','c','d','e','f','g','h']
    ls=[lista[i] for i in [2,3,6]]                # prvi primer, gde smo znali indekse
    print(ls)

.. activecode:: comprehension2
    :nocodelens: 

    samoglasnici=['a','e','i','o','u']
    lista=['a','b','c','d','e','f','g','h']
    ls=[x for x in lista if x in samoglasnici]    # drugi primer, gde smo znali kriterijum
    print(ls)

.. questionnote::

    Помоћу *list comprehension* конструкције одреди и испиши
    разлику две листе, односно вредности свих елемената који се налазе у
    првој, а не налазе у другој листи.
